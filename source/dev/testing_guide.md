# Testing Guide

## Minimum Requirement
* Demonstrate that a particular functionality is working
* Show that the effect of new code is understood, and less likely to interact with the rest of code base in unexpected ways
* Validate that a bug has been fixed and we can detect the problem in the future

## What's the Benefit to the Team?
* Reading test code allows others to more easily understand and work with our code
* Ensures a consistent level of functionality testing for all subsequent changes
* Speeds up future changes because we can instantly test to see if a change works as expected


## How do we Test if a Feature Works?
Since we're dealing with data, it helps to have a toy model which has the following characteristics:
* Has enough variation to the test different cases which arise due to branching in the code (e.g., include generators of different types to test that code handles scaling for the right type of generators)
* Yet still small enough to be able to verify overall correctness manually
* Particular values in the data set are easy to work with and confirm manually (e.g., use `5` instead of `4.624754`)
* Includes just the data needed for the code to run - in testing it is better to have an error if the code ever attempts to change something unexpectedly


## Examples
### Let's Start Easy
You develop a new feature and you need a helper function that calculates the square root of a number. The function will be declared in a `helpers` module and the tests will be written in a `test_helpers` module located in a **tests** folder at the same level as the `helpers` module. Three tests should be written for this function:
* Test the argument type
* Test the argument value
* Test the returned value

The function would read:
```python
def calculate_square_root(number):
    """Calculate the nth root of a number.

    :param int/float number: positive number.
    :return: (*float*) -- principal square root of number.
    :raises TypeError: if number has wrong type.
    :raises ValueError: if number is negative.
    """
    if not isinstance(number, (int, float)):
      raise TypeError("number must be a int or float")

    if number < 0:
      raise ValueError("number must be positive")

    root = number ** (1.0 / 2)
    return root
```
and the tests will look like:
```python
def test_calculate_square_root_argument_type():
    arg = ((4), [16], {9})
    for a in arg:
        with pytest.raises(TypeError):
            calculate_squre_root(a)


def test_calculate_square_root_argument_value():
    with pytest.raises(ValueError):
        calculate_squre_root(-9)


def test_calculate_square_root():
    assert calculate_square_root(64) == 8.0
    assert calculate_square_root(49.0) == 7.0
    assert calculate_square_root(36.0) != 5
```


### Mock Objects
Let's consider a more complex scenario. We ran a scenario and as an output of the simulation, we get the power generated by a generator in the grid in a given hour (in MWh). We want to summarize this result by calculating the total power generated in an hour per bus. To do so, we need to relate each generator to its bus. This information is enclosed in the `Grid` class. The function will read:
```python
def summarize_plant_to_bus(pg, grid):
    """Take a plant-column data frame and sum to a bus-column data frame.

    :param pandas.DataFrame pg: indices are UTC timestamp and columns are plant id in grid.
    :param powersimdata.input.grid.Grid grid: a Grid instance.
    :return: (*pandas.DataFrame*) -- indices as input data frame, columns are buses.
    """
    all_buses_in_grid = grid.plant["bus_id"]
    buses_in_df = all_buses_in_grid.loc[pg.columns]
    bus_data = pg.T.groupby(buses_in_df).sum().T

    return bus_data
```
To test this function we need a couple of mock objects. One for the `pg` data frame and one for the `grid` object. We have developed a catalog of mock objects in the **powersimdata/tests/**.


Below we show how the `MockGrid` object can be used to test the `summarize_plant_to_bus` function:
```python
import pandas as pd
from numpy.testing import assert_array_equal
from powersimdata.tests.mock_grid import MockGrid

# plant_id is the index
mock_plant = {
    "plant_id": ["A", "B", "C", "D"],
    "bus_id": [1, 1, 2, 3],
}

# bus_id is the index
mock_bus = {
    "bus_id": [1, 2, 3],
    "lat": [47.6, 37.8, 40.7],
    "lon": [122.3, 122.4, 74],
}

mock_pg = pd.DataFrame(
    {"A": [1, 2, 3, 4], "B": [1, 2, 4, 8], "C": [1, 1, 2, 3], "D": [1, 3, 5, 7]},
    index=pd.date_range(start="2018-04-24", freq="H", periods=4),
)

grid = MockGrid({"plant": mock_plant, "bus": mock_bus})


def test_summarize_plant_to_bus():
    expected_return = pd.DataFrame(
        {1: [2, 4, 7, 12], 2: [1, 1, 2, 3], 3: [1, 3, 5, 7]},
        index=pd.date_range(start="2018-04-24", freq="H", periods=4),
    )
    bus_data = summarize_plant_to_bus(mock_pg, grid)
    assert_array_equal(bus_data.to_numpy(), expected_return.to_numpy())
```
